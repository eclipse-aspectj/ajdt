--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TheOriginalJDTScannerClass.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/TheOriginalJDTScannerClass.java
@@ -230,6 +230,7 @@ public class Scanner implements TerminalTokens {
 	private VanguardParser vanguardParser;
 	ConflictedParser activeParser = null;
 	private boolean consumingEllipsisAnnotations = false;
+	protected boolean multiCaseLabelComma = false;

 	public static final int RoundBracket = 0;
 	public static final int SquareBracket = 1;
@@ -273,6 +274,7 @@ public Scanner(
 	this.checkNonExternalizedStringLiterals = checkNonExternalizedStringLiterals;
 	this.previewEnabled = isPreviewEnabled;
 	this.caseStartPosition = -1;
+	this.multiCaseLabelComma = false;
 	if (taskTags != null) {
 		int taskTagsLength = taskTags.length;
 		int length = taskTagsLength;
@@ -1472,9 +1474,12 @@ public int getNextToken() throws InvalidInputException {
 		token = disambiguatedToken(token);
 	} else if (token == TokenNameELLIPSIS) {
 		this.consumingEllipsisAnnotations = false;
+	} else if (mayBeAtCasePattern(token)) {
+		token = disambiguateCasePattern(token);
 	}
 	this.lookBack[0] = this.lookBack[1];
 	this.lookBack[1] = token;
+	this.multiCaseLabelComma = false;
 	updateCase(token);
 	return token;
 }
@@ -3283,6 +3288,7 @@ public void resetTo(int begin, int end, boolean isModuleInfo, ScanContext contex
 	this.consumingEllipsisAnnotations = false;
 	this.insideModuleInfo = isModuleInfo;
 	this.scanContext = context == null ? getScanContext(begin) : context;
+	this.multiCaseLabelComma = false;
 }

 private ScanContext getScanContext(int begin) {
@@ -4989,6 +4995,7 @@ private static class Goal {
 	static int SwitchLabelCaseLhsRule = 0;
 	static int[] RestrictedIdentifierSealedRule;
 	static int[] RestrictedIdentifierPermitsRule;
+	static int[] PatternRules;

 	static Goal LambdaParameterListGoal;
 	static Goal IntersectionCastGoal;
@@ -4999,16 +5006,20 @@ private static class Goal {
 	static Goal SwitchLabelCaseLhsGoal;
 	static Goal RestrictedIdentifierSealedGoal;
 	static Goal RestrictedIdentifierPermitsGoal;
+	static Goal PatternGoal;

 	static int[] RestrictedIdentifierSealedFollow =  { TokenNameclass, TokenNameinterface,
 			TokenNameenum, TokenNameRestrictedIdentifierrecord };// Note: enum/record allowed as error flagging rules.
 	static int[] RestrictedIdentifierPermitsFollow =  { TokenNameLBRACE };
+	static int[] PatternCaseLabelFollow = {TokenNameCOLON, TokenNameARROW, TokenNameCOMMA};

 	static {

 		List<Integer> ridSealed = new ArrayList<>(2);
 		List<Integer> ridPermits = new ArrayList<>();
+		List<Integer> patternStates = new ArrayList<>();
 		for (int i = 1; i <= ParserBasicInformation.NUM_RULES; i++) {  // 0 == $acc
+			// TODO: Change to switch
 			if ("ParenthesizedLambdaParameterList".equals(Parser.name[Parser.non_terminal_index[Parser.lhs[i]]])) //$NON-NLS-1$
 				LambdaParameterListRule = i;
 			else
@@ -5035,10 +5046,22 @@ private static class Goal {
 			else
 			if ("SwitchLabelCaseLhs".equals(Parser.name[Parser.non_terminal_index[Parser.lhs[i]]])) //$NON-NLS-1$
 				SwitchLabelCaseLhsRule = i;
-
+			else
+			if ("TypePattern".equals(Parser.name[Parser.non_terminal_index[Parser.lhs[i]]])) //$NON-NLS-1$
+				patternStates.add(i);
+			else
+			if ("PrimaryPattern".equals(Parser.name[Parser.non_terminal_index[Parser.lhs[i]]])) //$NON-NLS-1$
+				patternStates.add(i);
+			else
+			if ("GuardedPattern".equals(Parser.name[Parser.non_terminal_index[Parser.lhs[i]]])) //$NON-NLS-1$
+				patternStates.add(i);
+			else
+			if ("Pattern".equals(Parser.name[Parser.non_terminal_index[Parser.lhs[i]]])) //$NON-NLS-1$
+				patternStates.add(i);
 		}
 		RestrictedIdentifierSealedRule = ridSealed.stream().mapToInt(Integer :: intValue).toArray(); // overkill but future-proof
 		RestrictedIdentifierPermitsRule = ridPermits.stream().mapToInt(Integer :: intValue).toArray();
+		PatternRules = patternStates.stream().mapToInt(Integer :: intValue).toArray();

 		LambdaParameterListGoal =  new Goal(TokenNameARROW, new int[] { TokenNameARROW }, LambdaParameterListRule);
 		IntersectionCastGoal =     new Goal(TokenNameLPAREN, followSetOfCast(), IntersectionCastRule);
@@ -5049,6 +5072,7 @@ private static class Goal {
 		SwitchLabelCaseLhsGoal =   new Goal(TokenNameARROW, new int [0], SwitchLabelCaseLhsRule);
 		RestrictedIdentifierSealedGoal = new Goal(TokenNameRestrictedIdentifiersealed, RestrictedIdentifierSealedFollow, RestrictedIdentifierSealedRule);
 		RestrictedIdentifierPermitsGoal = new Goal(TokenNameRestrictedIdentifierpermits, RestrictedIdentifierPermitsFollow, RestrictedIdentifierPermitsRule);
+		PatternGoal = new Goal(TokenNameBeginCaseElement, PatternCaseLabelFollow, PatternRules);
 	}


@@ -5250,6 +5274,10 @@ private VanguardScanner getNewVanguardScanner() {
 	vs.resetTo(this.startPosition, this.eofPosition - 1, isInModuleDeclaration(), this.scanContext);
 	return vs;
 }
+protected final boolean mayBeAtCasePattern(int token) {
+	return (this.complianceLevel == ClassFileConstants.JDK17 && this.previewEnabled)
+			&& (token == TokenNamecase || this.multiCaseLabelComma);
+}
 protected final boolean mayBeAtBreakPreview() {
 	return this.breakPreviewAllowed && this.lookBack[1] != TokenNameARROW;
 }
@@ -5347,6 +5375,7 @@ public void setActiveParser(ConflictedParser parser) {
 	if (parser != null) {
 		this.insideModuleInfo = parser.isParsingModuleDeclaration();
 	}
+	this.multiCaseLabelComma = false;
 }
 public static boolean isRestrictedKeyword(int token) {
 	switch(token) {
@@ -5657,6 +5686,25 @@ int disambiguatedToken(int token) {
 	}
 	return token;
 }
+/*
+ * Assumption: mayBeAtCasePattern(token) is true before calling this method.
+ */
+int disambiguateCasePattern(int token) {
+	assert mayBeAtCasePattern(token);
+	int delta = token == TokenNamecase ? 4 : 0; // 4 for case.
+	final VanguardParser parser = getNewVanguardParser();
+	parser.scanner.resetTo(parser.scanner.currentPosition + delta, parser.scanner.eofPosition);
+	if (parser.parse(Goal.PatternGoal) == VanguardParser.SUCCESS) {
+		if (token == TokenNamecase) {
+			this.nextToken = TokenNameBeginCaseElement;
+		} else {
+			this.nextToken = token;
+			token = TokenNameBeginCaseElement;
+		}
+	}
+	return token;
+}
+
 private boolean mayBeAtCaseLabelExpr() {
 	if (this.lookBack[1] == TokenNamedefault || this.caseStartPosition <= 0)
 		return false;
